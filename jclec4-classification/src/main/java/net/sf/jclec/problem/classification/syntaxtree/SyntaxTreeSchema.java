package net.sf.jclec.problem.classification.syntaxtree;

import net.sf.jclec.exprtree.IPrimitive;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfContinuousValues;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfDiscreteValues;
import net.sf.jclec.problem.classification.blocks.fuzzy.MembershipFunction;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.TerminalNode;
import net.sf.jclec.util.random.IRandGen;

/**
 * SyntaxTree Schema for SyntaxTreeClassificationRules.<p/>
 * 
 * Extends the SyntaxTreeSchema and defines the terminals map for the classification problem
 * based on the terminals generated from the metadata of the dataset.
 * 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Alberto Cano 
 * @author Juan Luis Olmo
 */

public class SyntaxTreeSchema extends net.sf.jclec.syntaxtree.SyntaxTreeSchema 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8548482239030974796L;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting SyntaxTreeSchema methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * {@inheritDoc}
	 */
	
	public void fillSyntaxBranch(SyntaxTree owner, String symbol, int nOfDer, IRandGen randgen)
	{
		if (isTerminal(symbol)) 
		{
			// If the selected symbol is terminal
			
			if(terminalsMap.get(symbol).getCode() instanceof RandomConstantOfContinuousValues )
			{
				TerminalNode terminalAux = new TerminalNode(symbol, new RandomConstantOfContinuousValues(randgen));
				((RandomConstantOfContinuousValues) terminalAux.getCode()).setInterval(((RandomConstantOfContinuousValues)terminalsMap.get(symbol).getCode()).getInterval());
				((RandomConstantOfContinuousValues) terminalAux.getCode()).initializeValue();
				owner.addNode(terminalAux);
			}
			else if(terminalsMap.get(symbol).getCode() instanceof RandomConstantOfDiscreteValues )
			{
				TerminalNode terminalAux = new TerminalNode(symbol, new RandomConstantOfDiscreteValues(randgen));
				((RandomConstantOfDiscreteValues) terminalAux.getCode()).setInterval(((RandomConstantOfDiscreteValues)terminalsMap.get(symbol).getCode()).getInterval());
				((RandomConstantOfDiscreteValues) terminalAux.getCode()).initializeValue();
				owner.addNode(terminalAux);
				
			}
			else if(terminalsMap.get(symbol).getCode() instanceof MembershipFunction )
			{
				IPrimitive membershipFunction = terminalsMap.get(symbol).getCode().copy();
				((MembershipFunction) membershipFunction).setRandgen(randgen);
				((MembershipFunction) membershipFunction).initializeLabel();
				TerminalNode terminalAux = new TerminalNode(symbol, membershipFunction);
				owner.addNode(terminalAux);
			}
			else
				owner.addNode(getTerminal(symbol));
		} 
		else {
			// If the selected symbol is non terminal
				
			NonTerminalNode selectedProduction = selectProduction(symbol, nOfDer, randgen); 
			if (selectedProduction != null) 
			{
				// Add this node
				owner.addNode(selectedProduction);
			
				// Select a partition for this production rule
				int [] selectedPartition = selectPartition(selectedProduction.getProduction(), nOfDer-1, randgen);
				// Apply partition, expanding production symbols
				int selProdSize = selectedPartition.length;
				
				for (int i=0; i<selProdSize; i++) 
					fillSyntaxBranch(owner, selectedProduction.getProduction()[i], selectedPartition[i], randgen);
			}
			else 
				fillSyntaxBranch(owner, symbol, nOfDer-1, randgen);		
		}
	}
}