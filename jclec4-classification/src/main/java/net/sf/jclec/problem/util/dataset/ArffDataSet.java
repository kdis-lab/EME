package net.sf.jclec.problem.util.dataset;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

import net.sf.jclec.problem.util.dataset.attribute.AttributeType;
import net.sf.jclec.problem.util.dataset.attribute.CategoricalAttribute;
import net.sf.jclec.problem.util.dataset.attribute.IAttribute;
import net.sf.jclec.problem.util.dataset.attribute.NumericalAttribute;
import net.sf.jclec.problem.util.dataset.instance.IInstance;
import net.sf.jclec.problem.util.dataset.instance.Instance;
import net.sf.jclec.problem.util.dataset.metadata.ClassificationMetadata;
import net.sf.jclec.util.range.Closure;
import net.sf.jclec.util.range.Interval;

/**
 * Dataset implementation for the ARFF format (Weka dataset).
 * 
 * The main method is loadInstances() that reads the dataset file, the metadata information and the instances.
 * 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Alberto Cano 
 * @author Juan Luis Olmo
 */

public class ArffDataSet extends FileDataset {

	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */
	
	private static final long serialVersionUID = 1L;

	/////////////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Internal Variables
	/////////////////////////////////////////////////////////////////////////
	
	 /** The keyword used to denote the relation name */
	
	static String ARFF_RELATION = "@RELATION";
	
	/** The keyword used to denote the attribute description */
	  
	static String ARFF_ATTRIBUTE = "@ATTRIBUTE";

	/** The keyword used to denote the start of the arff data section */
	  
	static String ARFF_DATA = "@DATA";
	
	/** Symbol which represents missed values */
	
	protected String missedValue;
	
	/** Symbol which represents commentted values */
	
	protected String commentedValue;
	
	/** Symbol which represents the separation between values */
	
	protected String separationValue;

	/** Buffer Instance */
	
	protected String bufferInstance = new String();

	/** Private cursor */
	private Instance cursorInstance;
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------------- Constructor
	/////////////////////////////////////////////////////////////////
	
	public ArffDataSet()
	{
		super();
		
		missedValue = "?";
		separationValue = ",";
		commentedValue = "%";
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Load instances from the data set
	 * 
	 * Open dataset, obtain metadata, read instances, close dataset
	 */
	
	public void loadInstances()
	{		
		try {
			
			open();
			
            instances = new ArrayList<IInstance>();
            
            reset();
            
            while(next())
            {
            	instances.add(cursorInstance.copy());
            }
            
            setInstances(instances);
            
            close();
            
            double[] minValues = new double[metadata.numberOfAttributes()-1];
            double[] maxValues = new double[metadata.numberOfAttributes()-1];
            
            for(int i = 0; i < minValues.length; i++)
            {
            	minValues[i] = Double.MAX_VALUE;
            	maxValues[i] = -Double.MAX_VALUE;
            }
            
            for(IInstance instance : instances)
            {
            	for(int i = 0; i < minValues.length; i++)
            	{
            		double value = instance.getValue(i);
            		
            		if(value < minValues[i])
            			minValues[i] = value;
            		if(value > maxValues[i])
            			maxValues[i] = value;
            	}
            }
            
            for(int i = 0; i < minValues.length; i++)
            	if(metadata.getAttribute(i).getType() == AttributeType.Numerical)
            	{
            		Interval interval = new Interval(minValues[i], maxValues[i], Closure.ClosedClosed);
            		((NumericalAttribute) metadata.getAttribute(i)).setInterval(interval);
            	}
        }
		catch (Exception e) 
        {
            e.printStackTrace();
        }
	}
	
	/**
	 * Set the dataset instances
	 * 
	 * @param instances the instances
	 */
	
	public void setInstances(ArrayList<IInstance> instances)
	{
		this.instances = instances;
	}
	
	/**
	 * Get the dataset instances
	 * 
	 * @return instances
	 */
	
	public ArrayList<IInstance> getInstances()
	{
		return instances;
	}
	
	/**
	 * Add the new instances to the dataset
	 * 
	 * @param newinstances instances to add
	 */
	
	public void addInstances(ArrayList<IInstance> newinstances)
	{
		this.instances.addAll(newinstances);
	}
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private Methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Opens the dataset and obtains the metadata
	 */
	
	private void open()
	{
		// Generate the specification from header of data source file
		obtainMetadata(fileName);
	}
	
	/**
	 * Resets the dataset cursor to the beginning
	 */
	
	private void reset()
	{
		try {
			fileReader.close();
			fileReader = new BufferedReader(new FileReader(new File(fileName)));

			//Read until finding the sentence @DATA
			String line = ((BufferedReader) fileReader).readLine();
			while (!line.equalsIgnoreCase(ARFF_DATA)){
				line = ((BufferedReader) fileReader).readLine();
			}
			bufferInstance = ((BufferedReader) fileReader).readLine();
		
			while(bufferInstance.startsWith(commentedValue) || bufferInstance.equalsIgnoreCase("")){
				bufferInstance = ((BufferedReader) fileReader).readLine();
			}
		
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (Exception e){
			e.printStackTrace();
		}
	
	}
	
	/**
	 * Reads the next instance
	 */
	
	private boolean next() throws Exception
	{
		if(bufferInstance != null)
		{
			try{
				//Get the attributes of this instance
				StringTokenizer token = new StringTokenizer(bufferInstance, separationValue);
				int numAttributes = 0;
				ArrayList<Double> values = new ArrayList<Double>();
			
				while(token.hasMoreTokens()){
					IAttribute attribute = metadata.getAttribute(numAttributes);
					double value = attribute.parse(token.nextToken().trim());
					values.add(value);
								
					numAttributes++;
				}
				
				cursorInstance = new Instance(numAttributes);
				
				for(int i = 0; i < numAttributes; i++)
					cursorInstance.setValue(i,values.get(i));
				
				prepareNextInstance();
			
			}catch(Exception e)
			{
				e.printStackTrace();
			}
			
			return true;
		}
		else
			return false;
	}
	
	/**
	 * Closes the dataset file
	 */
	
	private void close() throws Exception {
		try {
			fileReader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Generate the dataset specification
	 *  
	 * @param fileName Name of data source file
	 */
	
	private void obtainMetadata(String fileName)
	{
		File file = new File(fileName);
		
		metadata = new ClassificationMetadata();
		
		try {
			
			fileReader = new BufferedReader(new FileReader(file));
			
			//Read until finding the sentence @DATA
			String line = ((BufferedReader) fileReader).readLine();
			StringTokenizer elementLine = new StringTokenizer(line);
			String element = elementLine.nextToken();
			
			while (!element.equalsIgnoreCase(ARFF_DATA)){
				
				if(element.equalsIgnoreCase(ARFF_ATTRIBUTE)){
					//The next attribute	
					String name = elementLine.nextToken();
					String type = elementLine.nextToken();
					
					if(type.equalsIgnoreCase("REAL") || type.equalsIgnoreCase("NUMERIC")){
						addAttributeToSpecification(type, line, name);
					}
					else
						addAttributeToSpecification("STRING", line, name);
					
				}
				if(element.equalsIgnoreCase(ARFF_RELATION)){
					setName(elementLine.nextToken());
				}
		
				//Next line of the file
				line = ((BufferedReader) fileReader).readLine();
				while(line.startsWith(commentedValue) || line.equalsIgnoreCase(""))
					line = ((BufferedReader) fileReader).readLine();
				
				int index = line.indexOf('[');
				if(index != -1)
				line = line.substring(0,index) + " [" + line.substring(index+1);
				
				index = line.indexOf('{');
				if(index != -1)
				line = line.substring(0,index) + " {" + line.substring(index+1);
				
				elementLine = new StringTokenizer(line);
				element = elementLine.nextToken();
				
			}
					
			bufferInstance = ((BufferedReader) fileReader).readLine();
			
			while(bufferInstance.startsWith(commentedValue) || bufferInstance.equalsIgnoreCase("")){
				bufferInstance = ((BufferedReader) fileReader).readLine();
			}
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (Exception e){
			e.printStackTrace();
		}
	}
	
	
	/**
	 * Store the next instance in bufferInstance
	 */
	private void prepareNextInstance()
	{		
		try
		{
			//Get the next instance
			String lineInstance = ((BufferedReader) fileReader).readLine();
			while(lineInstance.startsWith(commentedValue) || lineInstance.equalsIgnoreCase("")){
				lineInstance = ((BufferedReader) fileReader).readLine();
			}	

			bufferInstance = lineInstance;
		
		}catch(Exception e){
				bufferInstance = null;
		}
	}
	
	
	/**
	 * Add new attribute to the dataset specification
	 * 
	 * @param type Attribute type
	 * @param interval Intervals value
	 * @param name Attribute name
	 */
	private void addAttributeToSpecification(String type, String interval, String name)
	{
		// If the attribute is numerical
		if(type.equalsIgnoreCase("REAL") || type.equalsIgnoreCase("NUMERIC"))
		{
				NumericalAttribute attribute = new NumericalAttribute();
				attribute.setName(name);
					
				Interval intervals = new Interval();
			
				intervals.setClosure(Closure.ClosedClosed);
								
				attribute.setInterval(intervals);
				
				//Add new attribute to the specification
				metadata.addAttribute(attribute);
		}
		else
		{
			//Obtain the categorical values
			int minIndex = interval.indexOf("{");
			int maxIndex = interval.indexOf("}");
			
			interval = interval.substring(minIndex+1, maxIndex);
			
			if(minIndex < maxIndex){
				CategoricalAttribute attribute = new CategoricalAttribute();
				attribute.setName(name);
		
				StringTokenizer categories = new StringTokenizer(interval, ",");
				List<String> categoriesList = new ArrayList<String>();
				
				while(categories.hasMoreTokens())
					categoriesList.add(categories.nextToken().trim());
			
				attribute.setCategories(categoriesList);

				//Add new attribute to the specification
				metadata.addAttribute(attribute);
			}
		}
	}
	
   /**
    * Copy method
    * 
    * @return A copy of this dataset
    */
	
	@Override
	public IDataset copy() {
		
		ArffDataSet dataset = new ArffDataSet();
		
		dataset.setMetadata(metadata.copy());
		
		ArrayList<IInstance> instances = new ArrayList<IInstance>();
		
		for(IInstance instance : this.instances)
			instances.add(instance.copy());
		
		dataset.setInstances(instances);
			
		return dataset;
	}
}