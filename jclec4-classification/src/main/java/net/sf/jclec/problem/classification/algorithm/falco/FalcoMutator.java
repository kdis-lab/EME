package net.sf.jclec.problem.classification.algorithm.falco;

import net.sf.jclec.problem.classification.blocks.RandomConstantOfContinuousValues;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfDiscreteValues;
import net.sf.jclec.syntaxtree.IMutateSyntaxTree;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;
import net.sf.jclec.syntaxtree.TerminalNode;
import net.sf.jclec.util.random.IRandGen;

/**
 * Mutator for Falco et al. 2002 - Discovering interesting classification rules with genetic programming<p/>
 * 
 * The mutator selects a random node from the parent tree. Depending on whether the selected node is a terminal or non-terminal 
 * symbol the following actions are performed: 
 *    non-terminal symbol: the subtree under the selected non-terminal symbol is destroyed and a complete new branch is generated.
 *    terminal symbol: the terminal symbol is changed to another compatible symbol (see selectOtherTerminalNode() method). 
 * 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Alberto Cano 
 * @author Juan Luis Olmo
 */

public class FalcoMutator implements IMutateSyntaxTree
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -2706522794304044852L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public FalcoMutator() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	@Override
	public SyntaxTree mutateSyntaxTree(SyntaxTree parent, SyntaxTreeSchema schema, IRandGen randgen) {

		// Select randomly a symbol in parent
		int p_branchStart = randgen.choose(0, parent.size());
		
		SyntaxTree son = new SyntaxTree();

		if (parent.getNode(p_branchStart) instanceof NonTerminalNode) 
		{
			NonTerminalNode selectedSymbol = (NonTerminalNode) parent.getNode(p_branchStart);

			int p_branchEnd = endOfBranch(parent, p_branchStart);

			for (int i = 0; i < p_branchStart; i++)
				son.addNode(parent.getNode(i).copy());

			// Set branch depth (to check maximum size)
			int p_branchDepth = parent.derivSize();
			int p_swapBranch = 0;
			for (int i = p_branchStart; i <= p_branchEnd; i++) 
				if (parent.getNode(i).arity() != 0)
					p_swapBranch++;

			int beforeValue = schema.getMaxDerivSize() - p_branchDepth + p_swapBranch;
			if (p_swapBranch < schema.getMinDerivSize())
				p_swapBranch = schema.getMinDerivSize();

			int nOfDer = randgen.choose(p_swapBranch, beforeValue);

			schema.fillSyntaxBranch(son, selectedSymbol.getSymbol(), nOfDer, randgen);
			for (int i = p_branchEnd + 1; i < parent.size(); i++)
				son.addNode(parent.getNode(i).copy());

		} 
		else {

			TerminalNode selectedSymbol = (TerminalNode) parent.getNode(p_branchStart);
			TerminalNode node = selectOtherTerminalNode(selectedSymbol,schema,randgen);
			
			if(node == null)
				p_branchStart--;
			
			for (int i = 0; i < p_branchStart; i++) 
				son.addNode(parent.getNode(i).copy());	
			
			if(node != null)
				son.addNode(node);
			
			if(node == null)
				p_branchStart++;
			
			for (int i = p_branchStart + 1; i < parent.size(); i++)
				son.addNode(parent.getNode(i).copy());
		}

		return son;
	}
	
	/**
	 * Gets the index of the final symbol of a production
	 * 
	 * @param tree the syntaxtree
	 * @param currentNode the node from which the production is done
	 * 
	 * @return the index of the final symbol of the production
	 */
	private final int endOfBranch(SyntaxTree tree, int currentNode) 
	{
		int count = 1;

		while (count != 0) 
		{
			count += tree.getNode(currentNode).arity() - 1;
			currentNode = currentNode + 1;
		}

		return currentNode - 1;
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Selects a compatible node to mutate
	 * 
	 * @param symbol current symbol
	 * @param schema SyntaxTreeSchema
	 * @param randgen random generator
	 * 
	 * @return a compatible node
	 */
	protected TerminalNode selectOtherTerminalNode(TerminalNode symbol, SyntaxTreeSchema schema, IRandGen randgen) 
	{
		if (symbol.getSymbol().equalsIgnoreCase("="))
			return schema.getTerminal("!=");

		if (symbol.getSymbol().equalsIgnoreCase("!="))
			return schema.getTerminal("=");

		if (symbol.getSymbol().equalsIgnoreCase("<")) 
		{
			if (randgen.raw() < 0.3)
				return schema.getTerminal(">");
			if (randgen.raw() < 0.6)
				return schema.getTerminal(">=");

			return schema.getTerminal("<=");
		}
		if (symbol.getSymbol().equalsIgnoreCase("<=")) 
		{
			if (randgen.raw() < 0.3)
				return schema.getTerminal(">");
			if (randgen.raw() < 0.6)
				return schema.getTerminal(">=");

			return schema.getTerminal("<");
		}
		if (symbol.getSymbol().equalsIgnoreCase(">")) 
		{
			if (randgen.raw() < 0.3)
				return schema.getTerminal("<");
			if (randgen.raw() < 0.6)
				return schema.getTerminal(">=");

			return schema.getTerminal("<=");
		}
		if (symbol.getSymbol().equalsIgnoreCase(">=")) 
		{
			if (randgen.raw() < 0.3)
				return schema.getTerminal(">");
			if (randgen.raw() < 0.6)
				return schema.getTerminal("<");

			return schema.getTerminal("<=");
		}

		if (symbol.getSymbol().equalsIgnoreCase("AND"))
			return schema.getTerminal("OR");

		if (symbol.getSymbol().equalsIgnoreCase("OR"))
			return schema.getTerminal("AND");
		
		if (symbol.getSymbol().equalsIgnoreCase("IN"))
			return schema.getTerminal("OUT");
		
		if (symbol.getSymbol().equalsIgnoreCase("OUT"))
			return schema.getTerminal("IN");
		
		if (symbol.getSymbol().equalsIgnoreCase("NOT"))
			return schema.getTerminal("NOT");

		if (symbol.getCode() instanceof RandomConstantOfContinuousValues) 
		{
			TerminalNode terminalAux = new TerminalNode(symbol.getSymbol(), new RandomConstantOfContinuousValues(randgen));
			net.sf.jclec.util.range.Interval interval = ((RandomConstantOfContinuousValues) symbol.getCode()).getInterval();
			((RandomConstantOfContinuousValues) terminalAux.getCode()).setInterval(interval);
			((RandomConstantOfContinuousValues) terminalAux.getCode()).initializeValue();

			return terminalAux;
		}

		if (symbol.getCode() instanceof RandomConstantOfDiscreteValues) 
		{
			TerminalNode terminalAux = new TerminalNode(symbol.getSymbol(), new RandomConstantOfDiscreteValues(randgen));
			net.sf.jclec.util.intset.Interval interval = ((RandomConstantOfDiscreteValues) symbol.getCode()).getInterval();
			((RandomConstantOfDiscreteValues) terminalAux.getCode()).setInterval(interval);
			((RandomConstantOfDiscreteValues) terminalAux.getCode()).initializeValue();

			return terminalAux;
		}

		return symbol;
	}
}