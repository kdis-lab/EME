package net.sf.jclec.problem.classification.base;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.IIndividual;
import net.sf.jclec.algorithm.PopulationAlgorithm;
import net.sf.jclec.problem.classification.IClassifier;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.selector.BettersSelector;
import net.sf.jclec.util.random.IRandGen;

import org.apache.commons.configuration.Configuration;

/**
 * Classification Algorithm<p/>
 * 
 * Abstract class which defines an evolutionary-based algorithm for classification problems.
 * Extends from PopulationAlgorithm the main methods for evolutionary computation.
 * Namely, doInit() for population initialization, doSelection() for parents selection,
 * doGeneration() for crossover/mutation operators, doReplacement() for individuals replacement,
 * doUpdate() to update the population for the next generation, and doControl() for defining the stop criteria.
 * 
 * The configure() method is overloaded to support the train/test dataset load using the parameters given in the configuration file.
 *  
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Alberto Cano 
 * @author Juan Luis Olmo
 */

public abstract class ClassificationAlgorithm extends PopulationAlgorithm 
{
	// ///////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	// ///////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -8711970425735016406L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////

	/** Classifier */

	protected IClassifier classifier;

	/** Training Dataset */
	
	private IDataset trainSet;
	
	/** Testing Dataset */
	
	private IDataset testSet;
	
	/** Iteration */

	protected int execution = 0;
	
	/** Random number generator */

	protected IRandGen randgen;
	
	/** Used in update phase */

	protected BettersSelector bettersSelector = new BettersSelector(this);
	
	/** Elitist individuals */

	protected List<IIndividual> eset = new ArrayList<IIndividual>();

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */

	public ClassificationAlgorithm() {
		super();
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------ Public methods
	// ///////////////////////////////////////////////////////////////
	
	/**
	 * Access to execution counter
	 * 
	 * @return The execution count
	 */

	public int getExecution() {
		return execution;
	}
	
	/**
	 * Get the classifier
	 * 
	 * @return the classifier
	 */

	public IClassifier getClassifier() {
		return classifier;
	}
	
	/**
	 * Set the classifier
	 * 
	 * @param classifier the classifier
	 */

	public void setClassifier(IClassifier classifier) {
		this.classifier = classifier;
	}

	/**
	 * Access to the train dataset
	 * 
	 * @return train dataset
	 */
	
	public IDataset getTrainSet() 
	{
		return trainSet;
	}

	/**
	 * Set the dataset for train the algorithm
	 * 
	 * @param dataset the data set
	 */
	
	public void setTrainSet(IDataset dataset) 
	{
		this.trainSet = dataset;
	}
	
	/**
	 * Access to the test dataset
	 * 
	 * @return test dataset
	 */
	
	public IDataset getTestSet() 
	{
		return testSet;
	}

	/**
	 * Set the dataset for test the algorithm
	 * 
	 * @param dataset test dataset
	 */
	
	public void setTestSet(IDataset dataset) 
	{
		this.testSet = dataset;
	}
	
	/**
	 * Initializes the randgen
	 */
	
	public void initRandGen()
	{
		this.randgen = super.createRandGen();
	}
	
	// ///////////////////////////////////////////////////////////////
	// ---------------------------- Implementing IConfigure interface
	// ///////////////////////////////////////////////////////////////

	/**
	 * Configuration method.
	 * 
	 * Configuration parameters for a Steady State algorithm are:
	 */

	public void configure(Configuration settings)
	{		
		// Call super.configure() method
		super.configure(settings);
		
		// Dataset settings
		setDatasetSettings(settings);
		
		initRandGen();
	}
	
	/////////////////////////////////////////////////////////////////
	//----------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Set the dataset settings
	 */
	@SuppressWarnings("unchecked")
	protected void setDatasetSettings(Configuration settings) {
		try {
			//Train and test set classname
			String datasetClassname = settings.getString("dataset[@type]");
			Class<? extends IDataset> datasetClass;
			datasetClass = (Class<? extends IDataset>) Class.forName(datasetClassname);
			
			// Training set
			setTrainSet(datasetClass.newInstance());
	 
			// Configure training set
			Configuration datasetSettings = settings.subset("dataset.train-data");
			getTrainSet().configure(datasetSettings);
	
			// Testing set
			setTestSet(datasetClass.newInstance());
			
			// Configure test set
			datasetSettings = settings.subset("dataset.test-data");
			getTestSet().configure(datasetSettings);
			
			// Load dataset instances
			getTrainSet().loadInstances();
			getTestSet().loadInstances();
			
			// Gets the attribute class
			String attributeClass = settings.getString("dataset.attribute-class-name");			
			
			if(attributeClass != null)
			{			
				int attributeClassIndex = getTrainSet().getMetadata().getIndex(attributeClass);
				getTrainSet().getMetadata().setClassIndex(attributeClassIndex);
				getTestSet().getMetadata().setClassIndex(attributeClassIndex);
			}
			else
			{
				getTrainSet().getMetadata().setClassIndex(getTrainSet().getMetadata().numberOfAttributes()-1);
				getTestSet().getMetadata().setClassIndex(getTestSet().getMetadata().numberOfAttributes()-1);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}		
	}
}