package net.sf.jclec.problem.classification.base;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.problem.classification.IClassifier;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.instance.IInstance;
import net.sf.jclec.problem.util.dataset.metadata.IMetadata;

/**
 * RuleBase for classification problems.<p/>
 * 
 * The rule-base implements a classifier which comprises a set of classification rules.
 * 
 * Main methods:
 *    The classify() method classifies a complete dataset and returns the class predictions for all the instances. 
 *    The getConfusionMatrix() method classifies a dataset and returns the confusion matrix.
 * 
 * @author Sebastian Ventura
 * @author Amelia Zafra
 * @author Jose M. Luna 
 * @author Alberto Cano 
 * @author Juan Luis Olmo
 */

public abstract class RuleBase implements IClassifier
{	
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 1L;
	
	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Classification Individual */

	protected List<Rule> rules = new ArrayList<Rule>();

	/** Default Class */
	
	protected double defaultClass;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public RuleBase() {
		super();
	}
	
	public RuleBase(double defaultC) {
		super();
		
		this.defaultClass = defaultC;
	}
	
	public RuleBase(List<Rule> rules, double defaultC) {
		super();
		
		this.rules = rules;
		this.defaultClass = defaultC;
	}
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------- Getting and setting properties
	/////////////////////////////////////////////////////////////////

	/**
	 * Set the classification rules
	 * 
	 * @param rules the rules
	 */
	
	public void setClassificationRules(List<Rule> rules)
	{
		this.rules = rules;
	}
	
	/**
	 * Get the classification rules
	 * 
	 * @return the rules
	 */
	
	public List<Rule> getClassificationRules()
	{
		return rules;
	}
	
	/**
	 * Get the default class
	 * 
	 * @return the default class
	 */
	
	public double getDefaultClass()
	{
		return defaultClass;
	}
	
	/**
	 * Set the default class
	 * 
	 * @param defaultClass the default class
	 */
	
	public void setDefaultClass(double defaultClass)
	{
		this.defaultClass = defaultClass;
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Add a new rule to the rule base
	 * 
	 * @param rule the rule
	 */
	
	public void addClassificationRule(Rule rule)
	{
		if(rules != null)
			rules.add(rule);
		else
		{
			rules = new ArrayList<Rule>();
			rules.add(rule);
		}
	}
	
	/**
	 * Add a new rule to the rule base at a certain position
	 * 
	 * @param index position
	 * @param rule the rule
	 */
	
	public void addClassificationRule(int index, Rule rule)
	{
		if(rules != null)
			rules.add(index, rule);
		else
		{
			rules = new ArrayList<Rule>();
			rules.add(rule);
		}
	}	
	
	/**
	 * Set a new rule within the rule base at a certain position
	 * 
	 * @param index position
	 * @param rule the rule
	 */
	
	public void setClassificationRule(int index, Rule rule)
	{
		if(rules != null)
			rules.set(index, rule);
		else
		{
			rules = new ArrayList<Rule>();
			rules.add(rule);
		}
	}

	/**
	 * Get the i-th rule from the rule base
	 * 
	 * @param index the rule index
	 * @return the rule
	 */
	
	public Rule getClassificationRule(int index)
	{
		return rules.get(index);
	}
	
	 /**
     * Obtain the number of conditions from the rule base
     * 
     * @return number of conditions
     */
	
	public int getConditions()
	{
		int count = 0;
		
		for(Rule rule : rules) 
			count += rule.getConditions();
		
		return count;
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting java.lang.Object methods
	/////////////////////////////////////////////////////////////////
	
	@Override
	public boolean equals(Object other) 
	{
		if (other instanceof RuleBase) {
			RuleBase cother = (RuleBase) other;
			
			if(rules.size() != cother.rules.size())
				return false;
			
			for(int i = 0; i < rules.size(); i++)
				if(!rules.get(i).equals(cother.rules.get(i)))
					return false;
			
			return true;
		}
		else
			return false;
	}
	
	/** 
	 *  Classifies all the instances within the data set
	 *  
	 *  @param dataset the dataset
	 *  @return array of class predictions
	 */
	
	@Override
	public double[] classify(IDataset dataset)
	{
		ArrayList<IInstance> instances = dataset.getInstances();
		double[] predicted = new double[instances.size()];
		
		for(int i = 0; i < instances.size(); i++)
			predicted[i] = classify(instances.get(i));
		
		return predicted;
	}
	
	/**
	 * Obtains the confusion matrix for a dataset
	 * 
	 * @param dataset the dataset
	 * @return the confusion matrix
	 */
	
	public int[][] getConfusionMatrix(IDataset dataset)
	{
		IMetadata metadata = dataset.getMetadata();
		ArrayList<IInstance> instances = dataset.getInstances();
		int [][] confusionMatrix = new int[metadata.numberOfClasses()][metadata.numberOfClasses()];
		
		double [] predicted = classify(dataset);
		
		for(int i = 0; i < instances.size(); i++) 
    	{
			confusionMatrix[(int) instances.get(i).getValue(metadata.getClassIndex())][(int) predicted[i]]++;
    	}
		
		return confusionMatrix;
	}
	
	public abstract RuleBase copy();
}