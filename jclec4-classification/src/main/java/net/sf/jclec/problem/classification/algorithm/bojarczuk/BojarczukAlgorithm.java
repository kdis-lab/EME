package net.sf.jclec.problem.classification.algorithm.bojarczuk;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.IConfigure;
import net.sf.jclec.IIndividual;
import net.sf.jclec.IRecombinator;
import net.sf.jclec.ISelector;
import net.sf.jclec.base.FilteredRecombinator;
import net.sf.jclec.problem.classification.base.ClassificationAlgorithm;
import net.sf.jclec.problem.classification.base.Rule;
import net.sf.jclec.problem.classification.crisprule.CrispRuleBase;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeRuleIndividual;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConfigurationRuntimeException;
import org.apache.commons.lang.builder.EqualsBuilder;

/**
 * Classifier algorithm for Bojarczuk et al. 2004 - A constrained-syntax genetic programming system for discovering classification rules: application to medical data sets<p/>
 * 
 * The Bojarczuk et al. algorithm performs mutation and reproduction to evolve rules whose consequent is evaluated for each of the data classes.
 * 
 * The configure() method set ups the algorithm according to the parameters from the configuration file.
 * The doSelection() method selects the parents from the current population via tournament selection.
 * The doGeneration() method applies the recombination operator and evaluates the fitness of the offspring.
 * The doUpdate() method applies reproduction and selects the best individuals for the next generation.
 * The doControl() method defines the stop criterion that is the maximum number of generations.
 * 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Alberto Cano 
 * @author Juan Luis Olmo
 */

public class BojarczukAlgorithm extends ClassificationAlgorithm 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8711970425735016406L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Parents selector */
	
	protected ISelector parentsSelector;
	
	/** Individuals recombinator */

	protected FilteredRecombinator recombinator;
	
	/** Copy probability */
	
	private double copyProb;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */
	
	public BojarczukAlgorithm() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------------- Getting and setting properties
	/////////////////////////////////////////////////////////////////

	/**
	 * Access the parent selection method
	 * 
	 * @return parentsSelector
	 */
	
	public ISelector getParentsSelector() 
	{
		return parentsSelector;
	}
	
	/**
	 * Establishes the parent selection method
	 * 
	 * @param parentsSelector the parent selector
	 */

	public void setParentsSelector(ISelector parentsSelector) 
	{
		// Set parents selector
		this.parentsSelector = parentsSelector;
		// Contextualize selector
		parentsSelector.contextualize(this);	
	}
	
	/**
	 * Access to parents recombinator
	 * 
	 * @return Actual parents recombinator
	 */
	
	public FilteredRecombinator getRecombinator() 
	{
		return recombinator;
	}

	/**
	 * Sets the parents recombinator.
	 * 
	 * @param recombinator the parents recombinator
	 */
	
	public void setRecombinator(IRecombinator recombinator) 
	{
		if (this.recombinator == null) 
			this.recombinator = new FilteredRecombinator (this);

		this.recombinator.setDecorated(recombinator);
	}
	
	/**
	 * Access to "copyProb" property.
	 * 
	 * @return Current copy probability
	 */
	
	public double getCopyProb() 
	{
		return copyProb;
	}

	/**
	 * Set the "copyProb" property.
	 * 
	 * @param copyProb the copy probability
	 */
	
	public void setCopyProb(double copyProb) 
	{
		this.copyProb = copyProb;
	}
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Set the recombinator probability
	 * 
	 * @param recProb the recombination probability
	 */
	
	private void setRecombinationProb(double recProb) 
	{
		((FilteredRecombinator) this.recombinator).setRecProb(recProb);
	}	
	
	/**
	 * Set the parent selector settings
	 * 
	 * @param settings the configuration settings
	 */
	@SuppressWarnings("unchecked")
	private void setParentsSelectorSetting(Configuration settings) {
		try {
			// Selector classname
			String parentsSelectorClassname = 
				settings.getString("parents-selector[@type]");
			// Species class
			Class<? extends ISelector> parentsSelectorClass = 
				(Class<? extends ISelector>) Class.forName(parentsSelectorClassname);
			// Species instance
			ISelector parentsSelector = parentsSelectorClass.newInstance();
			
			// Configure species if necessary
			if (parentsSelector instanceof IConfigure) {
				// Extract species configuration
				Configuration parentsSelectorConfiguration = settings.subset("parents-selector");
				// Configure species
				((IConfigure) parentsSelector).configure(parentsSelectorConfiguration);
			}
			
			// Set species
			setParentsSelector(parentsSelector);
		} 
		catch (ClassNotFoundException e) {
			throw new ConfigurationRuntimeException("Illegal parents selector classname");
		} 
		catch (InstantiationException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of parents selector", e);
		} 
		catch (IllegalAccessException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of parents selector", e);
		}		
	}
	
	/**
	 * Set the recombinator settings
	 * 
	 * @param settings the configuration settings
	 */
	@SuppressWarnings("unchecked")
	private void setRecombinatorSetting(Configuration settings) {
		try {
			// Recombinator classname
			String recombinatorClassname = 
				settings.getString("recombinator[@type]");
			// Recombinator class
			Class<? extends IRecombinator> recombinatorClass = 
				(Class<? extends IRecombinator>) Class.forName(recombinatorClassname);
			// Recombinator instance
			IRecombinator recombinator = recombinatorClass.newInstance();
			// Configure recombinator if necessary
			if (recombinator instanceof IConfigure) {
				// Extract recombinator configuration
				Configuration recombinatorConfiguration = settings.subset("recombinator");
				// Configure species
				((IConfigure) recombinator).configure(recombinatorConfiguration);
			}
			// Set species
			setRecombinator(recombinator);
		} 
		catch (ClassNotFoundException e) {
			throw new ConfigurationRuntimeException("Illegal recombinator classname");
		} 
		catch (InstantiationException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of recombinator", e);
		} 
		catch (IllegalAccessException e) {
			throw new ConfigurationRuntimeException("Problems creating an instance of recombinator", e);
		}
		// Recombination probability 
		double recProb = settings.getDouble("recombinator[@rec-prob]");
		setRecombinationProb(recProb);
	}
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------- Implementing IConfigure interface
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Configuration method
	 * 
	 * @param settings the configuration settings
	 */

	public void configure(Configuration settings)
	{
		settings.addProperty("species[@type]", "net.sf.jclec.problem.classification.algorithm.bojarczuk.BojarczukSyntaxTreeSpecies");
		settings.addProperty("evaluator[@type]", "net.sf.jclec.problem.classification.algorithm.bojarczuk.BojarczukEvaluator");
		settings.addProperty("provider[@type]", "net.sf.jclec.syntaxtree.SyntaxTreeCreator");
		settings.addProperty("parents-selector[@type]", "net.sf.jclec.selector.TournamentSelector");
		
		settings.addProperty("recombinator[@type]", "net.sf.jclec.syntaxtree.SyntaxTreeRecombinator");
		settings.addProperty("recombinator[@rec-prob]", settings.getDouble("recombination-prob",0.8));
		settings.addProperty("recombinator.base-op[@type]", "net.sf.jclec.syntaxtree.rec.SelectiveCrossover");
		
		//Call super.configure() method
		super.configure(settings);
		
		classifier = new CrispRuleBase();
		
		// Establishes the metadata for the species
		((BojarczukSyntaxTreeSpecies) species).setMetadata(getTrainSet().getMetadata());
		
		//Get max-tree-depth
		int maxDerivSize = settings.getInt("max-deriv-size");
		((BojarczukSyntaxTreeSpecies) species).setGrammar();
		((BojarczukSyntaxTreeSpecies) species).setMaxDerivSize(maxDerivSize);
		
		// Establishes the training set for evaluating
		((BojarczukEvaluator) evaluator).setDataset(getTrainSet());
		((BojarczukEvaluator) evaluator).setMaxDerivSize(maxDerivSize);
		
		// Parents selector
		setParentsSelectorSetting(settings);
		
		// Recombinator
		setRecombinatorSetting(settings);
		
		// Set copy probability
		double copyProb = settings.getDouble("copy-prob",0.1);
		setCopyProb(copyProb);
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting java.lang.Object methods
	/////////////////////////////////////////////////////////////////

	public boolean equals(Object other)
	{
		if (other instanceof BojarczukAlgorithm) {
			BojarczukAlgorithm cother = (BojarczukAlgorithm) other;
			EqualsBuilder eb = new EqualsBuilder();
			// Call super method
			eb.appendSuper(super.equals(other));
			// Parents selector
			eb.append(parentsSelector, cother.parentsSelector);
			// Recombinator
			eb.append(recombinator, cother.recombinator);
			// Return test result
			return eb.isEquals();
		}
		else 
			return false;
	}
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------- Overwriting BaseAlgorithm methods
	/////////////////////////////////////////////////////////////////
	
	@Override
	protected void doSelection() 
	{
		pset = parentsSelector.select(bset, populationSize);
		pset.addAll(eset);
	}

	@Override
	protected void doGeneration() 
	{
		// Recombine parents
		cset = recombinator.recombine(pset);
		cset.addAll(recombinator.getSterile());
		
		// Evaluate all new individuals
		evaluator.evaluate(cset);
	}
	
	@Override
	protected void doReplacement() {
	}

	@Override
	protected void doUpdate() 
	{
		// Do the reproduction operator		
		for(IIndividual individual : bset)
		{
			if(randgen.coin(copyProb))
				cset.add(individual.copy());
		}
		
		List<Rule> classificationRule = new ArrayList<Rule>();
		List<Double> classes = new ArrayList<Double>();
		
		// We leave space for the best rules per class that existed in the previous population
		if(cset.size() + getTrainSet().getMetadata().numberOfClasses() > populationSize)
			bset = bettersSelector.select(cset, populationSize-getTrainSet().getMetadata().numberOfClasses());
		else
			bset = bettersSelector.select(cset);
		
		bset.addAll(eset);
		
		eset = new ArrayList<IIndividual>();
		
		//Select the best individual for each class
		for(int i=0; i < bset.size() && classes.size() != getTrainSet().getMetadata().numberOfClasses(); i++)
		{
			Rule rule = (Rule) ((SyntaxTreeRuleIndividual) bset.get(i)).getPhenotype();
			rule.setFitness(bset.get(i).getFitness());
			
			if(!classes.contains(rule.getConsequent()))
			{
				boolean added = false;
				
				for(int j = 0; j < classificationRule.size(); j++)
				{
					if(getEvaluator().getComparator().compare(classificationRule.get(j).getFitness(),rule.getFitness()) <= 0)
					{
						classificationRule.add(j,rule);
						added = true;
						break;
					}
				}
				
				if(!added)
					classificationRule.add(rule);
				
				classes.add(rule.getConsequent());
				
				eset.add(bset.get(i).copy());
			}
		}
		
		((CrispRuleBase) classifier).setClassificationRules(classificationRule); 
	
		cset = pset = rset = null;
	}
	
	@Override
	protected void doControl()
	{
		// If maximum number of generations is exceeded, evolution is finished
		if (generation >= maxOfGenerations) {
			state = FINISHED;
			return;
		}
	}
}