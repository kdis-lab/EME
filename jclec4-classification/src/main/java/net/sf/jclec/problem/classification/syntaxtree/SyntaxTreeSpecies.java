package net.sf.jclec.problem.classification.syntaxtree;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.problem.classification.blocks.AttributeValue;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfContinuousValues;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfDiscreteValues;
import net.sf.jclec.problem.util.dataset.attribute.CategoricalAttribute;
import net.sf.jclec.problem.util.dataset.attribute.IAttribute;
import net.sf.jclec.problem.util.dataset.attribute.IntegerAttribute;
import net.sf.jclec.problem.util.dataset.attribute.NumericalAttribute;
import net.sf.jclec.problem.util.dataset.metadata.IMetadata;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.TerminalNode;

/**
 * SyntaxTree Species for SyntaxTreeClassificationRules.<p/>
 * 
 * Extends the SyntaxTreeSpecies and defines the terminal and non-terminal symbols for the classification problem
 * based on the properties from metadata of the dataset.
 * 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Alberto Cano 
 * @author Juan Luis Olmo
 */

public abstract class SyntaxTreeSpecies extends net.sf.jclec.syntaxtree.SyntaxTreeSpecies
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */

	private static final long serialVersionUID = 1L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////
	
	/** Genotype schema */
	
	protected SyntaxTreeSchema genotypeSchema;

	/** Dataset specification */
	
	protected IMetadata metadata;
	
	/** If categorical attributes exist, this variable is true*/
	
	protected boolean existCategoricalAttributes = false;
	
	/** If numerical attributes exist, this variable is true*/
	
	protected boolean existNumericalAttributes = false;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/** Empty constructor */
	
	public SyntaxTreeSpecies(){
		super();
	}
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------- Getting and setting properties
	/////////////////////////////////////////////////////////////////

	/**
	 * Access to genotype schema.
	 * 
	 * @return Genotype schema
	 */
	
	public SyntaxTreeSchema getGenotypeSchema() 
	{
		return genotypeSchema;
	}
	
	/**
	 * Get the metadata
	 *
	 * @return metadata
	 */
	
	public IMetadata getMetadata() 
	{
		return metadata;
	}

	/**
	 * Set the metadata
	 *
	 * @param metadata dataset specification
	 */
	
	public void setMetadata(IMetadata metadata) 
	{
		this.metadata = metadata;
	}
	
	/**
	 * Set the maximum number of derivations in trees.
	 * 
	 * @param maxDerivSize Maximum derivation size
	 */
	
	public void setMaxDerivSize(int maxDerivSize)
	{	
		genotypeSchema.setMaxDerivSize(maxDerivSize);
	}
		
	/**
	 * Get the maximum number of derivations in trees.
	 * 
	 * @return maxDerivSize Maximum derivation size
	 */
	
	public int getMaxDerivSize()
	{
		return genotypeSchema.getMaxDerivSize();
	}	

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 *  Through the specification of the dataset, it will be generated the grammar to be used during execution
	 */
	
	public void setGrammar()
	{
		List<IAttribute> inputAttributes = new ArrayList<IAttribute>();
		
		//Obtains the input attributes
		for(int i = 0; i < metadata.numberOfAttributes(); i++)
			if(i != metadata.getClassIndex())
				inputAttributes.add(metadata.getAttribute(i));
		
		List<TerminalNode> terminals = setTerminalSymbols(inputAttributes);
		List<NonTerminalNode> nonTerminals = setNonTerminalSymbols(inputAttributes);
		
		//Fix the gramatical values
		genotypeSchema = new SyntaxTreeSchema();
		genotypeSchema.setRootSymbol("antecedent");
		
		setTerminalNodes(terminals);
		setNonTerminalNodes(nonTerminals);			
	}
	
	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Establishes the terminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of terminal symbols
	 */
	protected List<TerminalNode> setTerminalSymbols(List<IAttribute> inputAttributes)
	{
		List<TerminalNode> terminals = new ArrayList<TerminalNode>();
		
		// Number of input attribute
		int numAttributes = inputAttributes.size();
		
		//Set terminal symbol
		for(int i = 0; i < numAttributes; i++)
		{
			//Creates a new terminal symbol and adds it to the list
			IAttribute attribute = inputAttributes.get(i);
			TerminalNode term = new TerminalNode(attribute.getName(), new AttributeValue());
			((AttributeValue) term.getCode()).setAttributeIndex(i);
			terminals.add(term);			
			
			TerminalNode termValue;
			//Checks the attribute type and assign the value type
			switch(attribute.getType())
			{
				case Numerical:
					termValue = new TerminalNode("values"+attribute.getName(), new RandomConstantOfContinuousValues());
					((RandomConstantOfContinuousValues) termValue.getCode()).setInterval(((NumericalAttribute) attribute).intervalValues());
					terminals.add(termValue);
					existNumericalAttributes = true;
					break;
				case Integer:
					termValue = new TerminalNode("values"+attribute.getName(), new RandomConstantOfDiscreteValues());
					((RandomConstantOfDiscreteValues) termValue.getCode()).setInterval(((IntegerAttribute) attribute).intervalValues());
					terminals.add(termValue);
					existNumericalAttributes = true;
					break;
				case Categorical:
					termValue = new TerminalNode("values"+attribute.getName(), new RandomConstantOfDiscreteValues()); 
					((RandomConstantOfDiscreteValues) termValue.getCode()).setInterval(((CategoricalAttribute) attribute).intervalValues());
					terminals.add(termValue);
					existCategoricalAttributes = true;
					break;
				default:
					System.out.println("Type is not supported");
			}
		}
		
		return terminals;
	}
	
	/**
	 * Set the terminal nodes
	 * 
	 * @param terminals list of terminal nodes
	 */
	
	private void setTerminalNodes(List<TerminalNode> terminals)
	{
		TerminalNode [] terminalsAux = new TerminalNode[terminals.size()];
		int i = 0;
		
		for(TerminalNode t: terminals)
			terminalsAux[i++] = (TerminalNode) t.copy();
		
		genotypeSchema.setTerminals(terminalsAux);
	}
	
	/**
	 * Set the non-terminal nodes
	 * 
	 * @param nonTerminals list of non terminal nodes
	 */
	
	private void setNonTerminalNodes(List<NonTerminalNode> nonTerminals)
	{
		NonTerminalNode [] nonTerminalsAux = new NonTerminalNode[nonTerminals.size()];
		int i = 0;
		
		for(NonTerminalNode t: nonTerminals)
			nonTerminalsAux[i++] = (NonTerminalNode) t.copy();
	
		genotypeSchema.setNonTerminals(nonTerminalsAux);
	}

	/**
	 * Establishes the nonterminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of nonterminal symbols
	 */
	
	protected abstract List<NonTerminalNode> setNonTerminalSymbols(List<IAttribute> inputAttributes);

	/**
	 * {@inheritDoc}
	 */
	
	public abstract SyntaxTreeRuleIndividual createIndividual(SyntaxTree genotype);
}